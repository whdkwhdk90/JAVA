-- 계정 새로 만들기
-- 시스템 계정에 들어가서 test계정 생성
CREATE USER TEST IDENTIFIED BY TEST;

-- 권한 부여
GRANT CONNECT, RESOURCE TO TEST;
--CMD창에서 SQLPLUS에서 계정을 확인해 본다.

--디비버에서 권한 준 계정으로 데이터베이스 생성
--생성할 때, FIND CLASS -> ORACLE.JDBC.DRIVE.DRACLEDRIVER 설정

--DDL
/*
	CREATE : 데이터 베이스의 객체를 생성하는 DDL
	[사용형식]
	CREATE : 객체 형태 객체명 (관련 내용)
	
	-- 테이블 생성 시
	CREATE TABLE 테이블명(
			컬럼명 자료형(길이) 제약조건
	);	 
	제약조건 : 테이블에 데이터를 저장하고자 할 때 지켜야 하는 규칙
			NOT NULL - NULL값 허용하지 않겠다.(필수 입력 사항) 
			UNIQUE - 중복 값을 허용하지 않는다.
			CHECK - 지정한 입력 사항 외에는 받지 못하게 막는 조건
			PRIMARY KEY - (NOT NULL + UNIQUE)  - 유니크 제약조건이 들어가있음.
				테이블 내에서 해당 행을 인식할 수 있는 고유의 값
				테이블 내에서 단 1개만 존재 가능
  			FOREIGN KEY - 다른 테이블에서 지정된 값을 연결지어 참조로 가져오는 데이터에 지정하는 제약조건
 */

-- 테이블 생성
-- 데이터를 저장하기 위한 객체
-- 2차원의 표 형태로 데이터를 담을 수 있다. 행과 컬럼으로 구성
CREATE TABLE MEMBER (
		MEMBER_NO NUMBER,						--회원번호
		MEMBER_ID VARCHAR2(20)	,			--회원아이디
		MEMBER_PWD VARCHAR2(20),		--회원비밀번호
		MEMBER_NAME VARCHAR2(15)		--회원이름
);
SELECT * FROM MEMBER;

-- 테이블의 각 컬럼에 주석 달기
-- COMMENT ON COLUMN 테이블명.컬럼명 IS '주석내용';
COMMENT ON COLUMN MEMBER.MEMBER_NO IS '회원 번호';
COMMENT ON COLUMN MEMBER.MEMBER_ID IS '회원 아이디';
COMMENT ON COLUMN MEMBER.MEMBER_PWD IS '회원 비밀번호';
COMMENT ON COLUMN MEMBER.MEMBER_NAME IS '회원 이름';

--테이블 정보 확인(CMD창 켜서 로그인 후 밑 명령어 작성)
DESC MEMBER;

SELECT *
FROM USER_TAB_COLUMNS;

SELECT *
FROM USER_TAB_COLUMNS
WHERE TABLE_NAME = 'MEMBER';
--테이블 주석 조회
SELECT *
FROM USER_TAB_COMMENTS;
--컬럼 주석 조회
SELECT *
FROM USER_COL_COMMENTS;

SELECT * FROM USER_TABLES;

-- 제약조건(CONSTRAINTS) -- 
-- 테이블을 생성할 때 각 컬럼에 값을 기록하는 것에 대한 제약사항을 설정하는 조건들
-- 데이터 무결성 보장 : 고유한 값이라는 혹은 값이 아무런 문제가 되지 않는다는 의미
--(데이터의 정확성을 보장하기 위해 정확하지 않은 데이터가 DB내에 저장되는 것을 방지)


-- 현재 사용자 계정에 관련된 제약 조건 확인
SELECT * FROM USER_CONS_COLUMNS;

-- NOT NULL
-- 'NULL 값을 허용하지 않는다.'
-- 컬럼에 반드시 값을 기록해야 하는 경우
-- 데이터 삽입/수정/삭제 시에 NULL 값을 허용하지 않도록 
-- 컬럼 작성 시 함께 제약조건 작성(컬럼레벨 제약조건 등록)

DROP TABLE USER_NOCONS;
CREATE TABLE USER_NOCONS(
		USER_NO NUMBER,
		USER_ID VARCHAR2(20),
		USER_PWD VARCHAR2(30),
		USER_NAME VARCHAR2(15),
		GENDER VARCHAR2(3),
		PHONE VARCHAR2(14),
		EMAIL VARCHAR2(30)
);
SELECT * FROM USER_NOCONS;
-- 테이블에 값 추가
-- DML : INSERT
INSERT INTO USER_NOCONS
VALUES(1, 'USER01','PASS01','이창진','남','010-1234-5678','LEE315@KH.OR.KR');

INSERT INTO USER_NOCONS
VALUES(2,NULL,NULL,NULL,'남',NULL,NULL);

SELECT * FROM USER_NOCONS;

CREATE TABLE USER_NOT_NULL(
			USER_NO NUMBER NOT NULL,				--컬럼레벨제약조건
			USER_ID VARCHAR2(20) NOT NULL,
			USER_PWD VARCHAR2(30) NOT NULL,
			USER_NAME VARCHAR2(15) NOT NULL,
			GENDER VARCHAR2(3),
			PHONE VARCHAR2(14),
			EMAIL VARCHAR2(30)
);

SELECT * FROM USER_NOT_NULL;

INSERT INTO USER_NOT_NULL
VALUES(1,'USER01','PASS01','이창진','남','010-1234-5678','LEE315@KH.OR.KR');

INSERT INTO USER_NOT_NULL
VALUES(2,NULL,NULL,NULL,'여',NULL,NULL);

-- UNIQUE 제약조건 --
-- 중복을 허용하지 않는 제약조건
-- 컬럼에 값을 입력/수정할 때 중복을 확인하여
-- 중복 값이 있을경우 값 추가/수정을 못하게 막는 제약조건

INSERT INTO USER_NOCONS
VALUES(1,'USER01','1234','홍길동','남','010-4333-2111','HONG@EXAMPLE.COM');

SELECT * FROM USER_NOCONS;

CREATE TABLE USER_UNIQUE(
			USER_NO NUMBER,
			USER_ID VARCHAR2(20) UNIQUE,
			USER_PWD VARCHAR2(30),
			USER_NAME VARCHAR2(15),
			GENDER CHAR(3),
			PHONE VARCHAR2(14),
			EMAIL VARCHAR2(30)
);
SELECT * FROM USER_UNIQUE;

INSERT INTO USER_UNIQUE
VALUES(1,'USER01','PASS01','이창진','남','010-1234-5678','LEE315@KH.OR.KR');
INSERT INTO USER_UNIQUE
VALUES(1,'USER01','1234','홍길동','여','010-4321-4321','HONG@EXAMPLE.COM');

SELECT * FROM USER_UNIQUE;

SELECT *
FROM USER_CONSTRAINTS C1, USER_CONS_COLUMNS C2
WHERE C1.CONSTRAINT_NAME = C2.CONSTRAINT_NAME
		AND C1.TABLE_NAME = 'USER_UNIQUE';  
--CONSTRAINT-TYPE
--U : UNIQUE
--P : PRIMARY KEY
--C : CHECK
--R : FORIEGN KEY(REFERENCE)


CREATE TABLE USER_UNIQUE2(
			USER_NO NUMBER,
--			USER_ID VARCHAR2(20) UNIQUE,
			USER_ID VARCHAR2(20),
			USER_PWD VARCHAR2(30),
			USER_NAME VARCHAR2(15),
			GENDER CHAR(3),
			PHONE VARCHAR2(14),
			EMAIL VARCHAR2(30),
			UNIQUE(USER_ID)							--컬럼이 모두 작성된 후에 별도로 작성하는 제약조건을
																	--테이블 레벨 제약조건이라고 함.
);


INSERT INTO USER_UNIQUE2
VALUES(1,'USER01','PASS01','이창진','남','010-1234-5678','LEE315@KH.OR.KR');
INSERT INTO USER_UNIQUE2
VALUES(1,'USER01','1234','홍길동','여','010-4321-4321','HONG@EXAMPLE.COM');

-- UNIQUE 제약조건을 여러 개 컬럼에 적용
-- 반드시 테이블 레벨에서 제약조건을 선언
CREATE TABLE USER_UNIQUE3(
			USER_NO NUMBER,
			USER_ID VARCHAR2(20),
			USER_PWD VARCHAR2(30),
			USER_NAME VARCHAR2(15),
			UNIQUE(USER_NO, USER_ID)				--두 개 이상의 컬럼값을 중복되지 않게 설정
);

SELECT * FROM USER_UNIQUE3;

INSERT INTO USER_UNIQUE3
VALUES(1,'USER01','PASS01','이창진');
INSERT INTO USER_UNIQUE3
VALUES(1,'USER02','PASS02','박창진');
INSERT INTO USER_UNIQUE3
VALUES(2,'USER01','PASSO3','김창진');
INSERT INTO USER_UNIQUE3
VALUES(2,'USER02','PASSO4','김창진');

-- UNIQUE안에 두 개 설정하면 두 개 모두 겹칠 때만 제약조건이 걸림.
INSERT INTO USER_UNIQUE3
VALUES(2,'USER02','PASSO5','강창진');

-- 제약조건 이름 설정
CREATE TABLE CONS_NAME(
			TEST_DATA1 NUMBER(10) CONSTRAINT NN_DATA1 NOT NULL,
			TEST_DATA2 VARCHAR2(20) CONSTRAINT UN_DATA2 UNIQUE,
			TEST_DATA3 VARCHAR2(30),
			CONSTRAINT UK_DATA3 UNIQUE(TEST_DATA3)
);

--
SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'CONS_NAME';

-- CHECK 제약조건
-- 컬럼에 값을 기록할 때 지정한 값 이외에는 값이 기록되지 않도록 범위를 제한하는 조건
-- CHECK(컬럼명 비교연산자 값)

CREATE TABLE USER_CHECK(
		USER_NO NUMBER,
		USER_ID VARCHAR2(20),
		USER_PWD VARCHAR2(30),
		USER_NAME VARCHAR2(15),
		GENDER CHAR(3) CHECK(GENDER IN('남','여'))
);

INSERT INTO USER_CHECK
VALUES(1,'USER01','PASS01','이창진','남');
--제약조건 전에 성별에서의 크기가 걸림
INSERT INTO USER_CHECK
VALUES(2,'USER02','PASS02','장하영','남자');
--크기가 작으니까 제약조건이 발동
INSERT INTO USER_CHECK
VALUES(2,'USER02','PASS02','장하영','M');

--CHECK 제약조건에 부등호 사용
CREATE TABLE TEST_CHECK2(
			TEST_DATA NUMBER(10),
			CONSTRAINT CK_TEST_DATA CHECK(TEST_DATA > 0)
);

INSERT INTO TEST_CHECK2
VALUES(10);
INSERT INTO TEST_CHECK2
VALUES(-10);

CREATE TABLE TEST_CHECK3(
		C_NAME VARCHAR2(15),
		C_PRICE NUMBER,
		C_DATE DATE,
		C_QUAL CHAR(1),
		CONSTRAINT CK_TESTCHK3_PRICE CHECK(C_PRICE BETWEEN 1 AND 9999),
		CONSTRAINT CK_TESTCHK3_DATE CHECK(C_DATE > TO_DATE('2010/01/01','YYYY/MM/DD')),
		CONSTRAINT CK_TESTCHK3_QUAL CHECK(C_QUAL >= 'A' AND C_QUAL <= 'D')		
);

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'TEST_CHECK3';

-- 제약 조건 여러개 설정하기
CREATE TABLE TEST_DUAL_CONS(
			TEST_NO NUMBER(10) NOT NULL UNIQUE,
			TEST_NO2 NUMBER NOT NULL
);

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'TEST_DUAL_CONS';

-- PRIMARY KEY 제약조건 --
-- '기본키 제약조건'
-- 테이블 내의 데이터 중에서 행을 식별하기 위한 고유값을 가지는 컬럼에
-- NOT NULL과 UNIQUE 제약조건을 함께 걸어주는 제약조건
-- (즉, 테이블 전체에 대한 각 데이터의 식별자 역할을 수행시키는 제약조건)
-- 기본키로 선언된 컬럼은 값이 반드시 들어가고, 중복이 일어나면 안됨.
-- 기본키 제약조건은 각 테이블 마다 반드시 한개 존재해야한다.
-- 기본키 제약조건은 한 컬럼에 적용 할 수도 있고, 여러컬럼을 묶어 적용할 수도 있다.

CREATE TABLE USER_PK_TABLE(
		USER_NO NUMBER(10) CONSTRAINT PK_USER_NO PRIMARY KEY,
		USER_ID VARCHAR2(20) UNIQUE,
		USER_PWD VARCHAR2(30) NOT NULL,
		USER_NAME VARCHAR2(15) NOT NULL,
		GENDER VARCHAR2(3) CHECK(GENDER IN('M','F'))
);

SELECT * FROM USER_PK_TABLE;

INSERT INTO USER_PK_TABLE
VALUES(1,'USER01','PASS01','LEE','M');

INSERT INTO USER_PK_TABLE
VALUES(2,'USER02','PASS02','KIM','F');

--unique constraint (TEST.PK_USER_NO) violated
INSERT INTO USER_PK_TABLE
VALUES(1,'USER03','PASS03','CHOI','F');
-- 기본키 설정하면 자동으로 유니크 제약조건 설정됨

--cannot insert NULL into ("TEST"."USER_PK_TABLE"."USER_NO")
INSERT INTO USER_PK_TABLE
VALUES(NULL,'USER03','PASS03','CHOI','F');
-- NOT NULL조건이 들어가있음

-- 기본키 제약 조건을 설정하면 NOT NULL과 UNIQUE가 함께 설정 된다.

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'USER_PK_TABLE';

-- 기본키 제약 조건을 여러 컬럼에 적용하기

CREATE TABLE USER_PK_TABLE2(
		USER_NO NUMBER(10),				
		USER_ID VARCHAR2(20) UNIQUE,
		USER_PWD VARCHAR2(30) NOT NULL,
		USER_NAME VARCHAR2(15) NOT NULL,
		GENDER VARCHAR2(3) CHECK(GENDER IN('M','F')),
		CONSTRAINT PK_USER_NO2 PRIMARY KEY(USER_NO, USER_ID)  --두개의 키를 묶어서 복합키라고도 함
);

-- 1,		'USER01'		-- 성공
-- 2,		'USER02'	-- 성공
-- 2,		'USER03'	-- 성공
-- 2,		'USER01'		-- 실패

INSERT INTO USER_PK_TABLE2
VALUES(1,'USER01','PASS01','LEE','M');
-- 복합키와는 별개로 이름에도 UNIQUE를 줘서 에러 발생
INSERT INTO USER_PK_TABLE2
VALUES(2,'USER01','PASS01','LEE','M');
INSERT INTO USER_PK_TABLE2
VALUES(1,'USER02','PASS01','LEE','M');

-- DROP : 객체를 삭제하는 명령어
DROP TABLE MEMBER;

SELECT * FROM MEMBER;

COMMIT;

-- MEMBER 테이블을 생성하여 사용자 정보를 받을 수 있는 테이블 객체를 만들되,
-- 회원 번호는 NUMBER형태로 기본키 설정하고,
-- 회원 아이디는 중복 불가에 필수 입력 사항으로,
-- 회원 비밀번호는 필수 입력 사항,
-- 회원 이름, 성별('M','F'),
-- 회원 연락처, 회원 생년월일 정보를 받을 수 있는 컬럼을 가진 테이블을 생성하시오.
-- 단, 각 컬럼의 길이는 직접 판단하고, 위에 생성된 테이블 기준으로
-- 회원 정보를 최소 5개 이상 삽입하여 확인하시오.

--내 버전
CREATE TABLE MEMBER(
		USER_NO NUMBER(10) PRIMARY KEY,		
		USER_ID VARCHAR2(20) NOT NULL UNIQUE,
		USER_PWD VARCHAR2(30) NOT NULL,
		USER_NAME VARCHAR2(15),
		GENDER VARCHAR2(3) CHECK(GENDER IN('M','F')),
		USER_EMAIL VARCHAR(30),
		USER_BIRTH VARCHAR(30)
);
SELECT * FROM MEMBER;

INSERT INTO MEMBER
VALUES(1,'USER01','PASS01','이준혁','M','@@@','9444');

INSERT INTO MEMBER
VALUES(2,'USER02','PASS02','삼준혁','M','@@@','9444');

INSERT INTO MEMBER
VALUES(3,'USER03','PASS03','삼준혁','M','@@@','9444');

INSERT INTO MEMBER
VALUES(4,'USER04','PASS04','사준혁','M','@@@','9444');

INSERT INTO MEMBER
VALUES(5,'USER05','PASS05','오준혁','M','@@@','9444');

-- 하영이 버전
CREATE TABLE MEMBER(
   USER_NO NUMBER(10),
   USER_ID VARCHAR2(20) NOT NULL UNIQUE,
   USER_PWD VARCHAR2(30) CONSTRAINT NN_USER_PWD NOT NULL,
   USER_NAME VARCHAR2(15),
   GENDER CHAR(3) CONSTRAINT CHK_GENDER CHECK(GENDER IN('M','F')),
   PHONE VARCHAR(14),
   BIRTHDAY DATE,
   CONSTRAINT PK1_USER PRIMARY KEY(USER_NO),
   CONSTRAINT BIRTHDAY CHECK( BIRTHDAY > TO_DATE('1900/01/01', 'YYYY/MM/DD') )
);

--강사님 버전
CREATE TABLE MEMBER(
		M_NO NUMBER CONSTRAINT PK_MEMBER PRIMARY KEY,
		M_ID VARCHAR2(15) NOT NULL UNIQUE,
		M_PWD VARCHAR2(30) NOT NULL,
		M_NAME VARCHAR2(15),
		M_GENDER CHAR(1) CHECK(M_GENDER IN('M','F')),
		M_MAIL VARCHAR2(30),
		P_PHONE VARCHAR2(14),
		M_BIRTH DATE
);

COMMENT ON COLUMN MEMBER.M_NO	IS '회원번호';
COMMENT ON COLUMN MEMBER.M_ID	IS '회원아이디';














