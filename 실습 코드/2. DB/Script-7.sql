
-- FOREIGN KEY(외래키, 외부키, 참조키) --
-- 다른 테이블의 컬럼값을 참조(REFERENCE)하여 참조하는 테이블의 값만 허용
-- FOREIGN KEY 제약조건을 통해 다른 테이블과의 관계(RELATIONSHIP)가 형성된다.

-- 컬럼레벨일 경우
-- 컬럼명 자료형(길이) [CONSTRAINT 제약조건명] REFERENCES 참조할 테이블명[(참조할 컬럼명)] [삭제옵션]

-- 테이블레벨일 경우
-- [CONSTRAINT 제약조건명] FOREIGN KEY(적용할 컬럼명) REFERENCES 참조할 테이블명[(참조할 컬럼명)] [삭제옵션]

DROP TABLE USER_GRADE;

CREATE TABLE USER_GRADE(
		GRADE_CODE NUMBER PRIMARY KEY,
		GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE VALUES(1,'일반 회원');
INSERT INTO USER_GRADE VALUES(2,'VIP');
INSERT INTO USER_GRADE VALUES(3,'VVIP');
INSERT INTO USER_GRADE VALUES(4,'VVVIP');

SELECT * FROM USER_GRADE;

CREATE TABLE USER_FOREIGN_KEY(
			USER_NO NUMBER PRIMARY KEY,
			USER_ID VARCHAR2(20),
			USER_PWD VARCHAR2(20),
			USER_NAME VARCHAR2(15),
			GENDER CHAR(1) CHECK(GENDER IN ('M','F')),
			GRADE_CODE NUMBER,
			CONSTRAINT FK_GRADE_CODE FOREIGN KEY (GRADE_CODE) REFERENCES USER_GRADE(GRADE_CODE)
																					--위의 GRADE_CODE는 한 줄 위의 컬럼,				--이 GRADE_CODE는 USER_GRADE테이블의 컬럼					
);

INSERT INTO USER_FOREIGN_KEY VALUES(1,'123','321','LEE','F',2);
INSERT INTO USER_FOREIGN_KEY VALUES(2,'ABC','ABC1','KIM','F',4);
INSERT INTO USER_FOREIGN_KEY VALUES(3,'456','456','CHOI','M',1);
INSERT INTO USER_FOREIGN_KEY VALUES(4,'DEF','DEF1','HONG','F',3);
INSERT INTO USER_FOREIGN_KEY VALUES(5,'QWE','QWE1','PARK','M',1);

SELECT * FROM USER_FOREIGN_KEY;

--integrity constraint (TEST.FK_GRADE_CODE) violated - parent key not found
--참조할 데이터에 10이 없기에 제약조건이 걸림
INSERT INTO USER_FOREIGN_KEY VALUES(6,'QWE','ABC','JANG','M',10);

SELECT *
FROM USER_FOREIGN_KEY
JOIN USER_GRADE USING(GRADE_CODE);


-- 삭제옵션
-- 참조하고 있는 원본 테이블의 컬럼 값이 삭제될 때 
-- 참조한 값을 어떻게 처리할 것인지 설정하는 옵션

--integrity constraint (TEST.FK_GRADE_CODE) violated - child record found
-- 지우려고 하는 컬럼이 다른테이블에서 참조하고 있어서 삭제 불가
DELETE FROM USER_GRADE WHERE GRADE_CODE = 4;

-- 삭제하기 전 참조하고 있는 자식에 옵션을 넣어두면 된다.
-- (참조를 하는 테이블은 자식테이블, 참조를 받는 테이블은 부모테이블)

-- 1. 부모 컬럼을 삭제할 때 자식을 NULL로 변경하기
-- ON DELETE SET NULL

-- 2. 부모 컬럼을 삭제할 때 관련된 지식도 함께 삭제하기
-- ON DELETE CASCADE

--unique/primary keys in table referenced by foreign keys
-- 누군가 USER_GRADE를 참조하고 있기 때문에 삭제 불가
-- USER_FOREIGN_KEY가 참조하고있으니까 밑에꺼부터 삭제하고 위에꺼 삭제하면 됨.
DROP TABLE USER_GRADE;
DROP TABLE USER_FOREIGN_KEY;

CREATE TABLE USER_GRADE(
		GRADE_CODE NUMBER PRIMARY KEY,
		GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE VALUES(1,'일반 회원');
INSERT INTO USER_GRADE VALUES(2,'VIP');
INSERT INTO USER_GRADE VALUES(3,'VVIP');
INSERT INTO USER_GRADE VALUES(4,'VVVIP');

SELECT * FROM USER_GRADE;

-- 연습 1. USER_FOREIGN_KEY + ON DELETE SET NULL
CREATE TABLE USER_FOREIGN_KEY(
			USER_NO NUMBER PRIMARY KEY,
			USER_ID VARCHAR2(20),
			USER_PWD VARCHAR2(20),
			USER_NAME VARCHAR2(15),
			GENDER CHAR(1) CHECK(GENDER IN ('M','F')),
			GRADE_CODE NUMBER,
			CONSTRAINT FK_GRADE_CODE FOREIGN KEY (GRADE_CODE) 
			REFERENCES USER_GRADE(GRADE_CODE) ON DELETE SET NULL
);

INSERT INTO USER_FOREIGN_KEY VALUES(1,'123','321','LEE','F',2);
INSERT INTO USER_FOREIGN_KEY VALUES(2,'ABC','ABC1','KIM','F',4);
INSERT INTO USER_FOREIGN_KEY VALUES(3,'456','456','CHOI','M',1);
INSERT INTO USER_FOREIGN_KEY VALUES(4,'DEF','DEF1','HONG','F',3);
INSERT INTO USER_FOREIGN_KEY VALUES(5,'QWE','QWE1','PARK','M',1);

COMMIT;
SELECT * FROM USER_FOREIGN_KEY;

DELETE FROM USER_GRADE WHERE GRADE_CODE = 4;

SELECT * FROM USER_FOREIGN_KEY;
SELECT * FROM USER_GRADE;

ROLLBACK;
--COMMIT을 한 시점으로 되돌아감

-- 연습2. USER_FOREIGN_KEY + ON DELETE CASCADE
-- 자식 테이블의 데이터 삭제된다.

DROP TABLE USER_FOREIGN_KEY;

CREATE TABLE USER_FOREIGN_KEY(
			USER_NO NUMBER PRIMARY KEY,
			USER_ID VARCHAR2(20),
			USER_PWD VARCHAR2(20),
			USER_NAME VARCHAR2(15),
			GENDER CHAR(1) CHECK(GENDER IN ('M','F')),
			GRADE_CODE NUMBER,
			CONSTRAINT FK_GRADE_CODE FOREIGN KEY (GRADE_CODE) 
			REFERENCES USER_GRADE(GRADE_CODE) ON DELETE CASCADE
);

INSERT INTO USER_FOREIGN_KEY VALUES(1,'123','321','LEE','F',2);
INSERT INTO USER_FOREIGN_KEY VALUES(2,'ABC','ABC1','KIM','F',4);
INSERT INTO USER_FOREIGN_KEY VALUES(3,'456','456','CHOI','M',1);
INSERT INTO USER_FOREIGN_KEY VALUES(4,'DEF','DEF1','HONG','F',3);
INSERT INTO USER_FOREIGN_KEY VALUES(5,'QWE','QWE1','PARK','M',1);

SELECT * FROM USER_FOREIGN_KEY;

COMMIT;

DELETE FROM USER_GRADE WHERE GRADE_CODE =2;
SELECT * FROM USER_GRADE;
SELECT * FROM USER_FOREIGN_KEY;

ROLLBACK;

-- 트랜잭션 (SELECT하고 INSERT하고 UPDATE하고 INSERT하고....)
-- 모두 성공하던가 모두 실패하던가가 보장되어야함.
-- 예를들어, SELECT INSERT 성공했는데 UPDATE가 실패하면 ROLLBACK으로 
-- SELECT INSERT가 성공하기 전으로 돌아가야 데이터 무결성이 보장받음.

-- SUBQUERY를 활용한 테이블 생성 --
-- 컬럼명, 데이터 타입, 값, NOT NULL은 복사된다.
-- 하지만 다른제약조건은 복사되지 않는다.

SELECT * FROM EMPLOYEE;

--EMPLOYEE_COPY안에 EMPLOYEE의 내용이 들어감(복사)
CREATE TABLE EMPLOYEE_COPY
AS SELECT * FROM EMPLOYEE;

SELECT * FROM EMPLOYEE_COPY;

-- 테이블의 형식만 복사하기(1과 2가 같을 때 즉, 데이터는 하나도 조회되지 않을 때)
CREATE TABLE EMPLOYEE_COPY2
AS SELECT * FROM EMPLOYEE WHERE 1 = 2;

SELECT * FROM EMPLOYEE_COPY2;

-- 각 컬럼에 값을 기록하지 않을 경우 기본값 설정하기
CREATE TABLE DEFAULT_TABLE(
			DATA_COL1 VARCHAR2(30) DEFAULT '없음',
			DATA_COL2 DATE DEFAULT SYSDATE
);

--아무런 값을 안넣은다고해서 공백을 두거나 하면 에러뜸
INSERT INTO DEFAULT_TABLE VALUES(DEFAULT, DEFAULT);
SELECT * FROM DEFAULT_TABLE;


-- 제약조건을 테이블 생성 후에 추가하는 DDL
-- ALTER 사용하기

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMPLOYEE';

-- [사용 형식]
-- ALTER TABLE 
-- ALTER TABLE 테이블명 ADD PRIMARY KEY(컬럼명)
-- ALTER TABLE 테이블명 ADD FOREIGN KEY(컬럼명) REFERENCES 테이블명(컬럼명)
-- ALTER TABLE 테이블명 ADD UNIQUE(컬럼명)
-- ALTER TABLE 테이블명 ADD CHECK(조건식)
-- ALTER TABLE 테이블명 MODIFY 컬럼명 NOT NULL

 -- 문제
 -- 		EMPLOYEE 테이블에서 
 -- DEPT_CODE에 외래키 제약 조건 추가
 -- 참조할 컬럼은 DEPARTMENT.DEPT_ID
 
 -- JOB_CODE에 외래키 제약 조건 추가
 -- 참조할 컬럼은 JOB.JOB_CODE
 
 -- SAL_LEVEL에 외래키 제약 조건 추가
 -- 참조할 컬럼은 SAL_GRADE.SAL_LEVEL
 
 -- ENT_YN 컬럼에 CHECK 제약조건 추가('Y','N') 대소문자 구분
 -- SALARY 컬럼에 CHECK 제약조건 추가( 무조건 양수 기입)
 -- EMP_NO 컬럼에 UNIQUE 제약 조건 추가
 
 --		DEPARTMENT 테이블에서
 -- LOCATION_ID에 외래키 제약조건 추가
 -- LOCATION 테이블의 기본키 컬럼
 -- 		LOCATION 테이블에서
 -- NATIONAL_CODE 외래키 제약 조건 추가
 -- NATIONAL 테이블의 기본키 컬럼
 
-- 다 만든 후에 USER_CONSTRAINTS에서 3개의 테이블 조회하기

ALTER TABLE EMPLOYEE ADD FOREIGN KEY(DEPT_CODE) REFERENCES DEPARTMENT(DEPT_ID);
ALTER TABLE EMPLOYEE ADD FOREIGN KEY(JOB_CODE) REFERENCES JOB(JOB_CODE);
ALTER TABLE EMPLOYEE ADD FOREIGN KEY(SAL_LEVEL) REFERENCES SAL_GRADE(SAL_LEVEL);
ALTER TABLE EMPLOYEE ADD CHECK(ENT_YN IN('Y','N'));
ALTER TABLE EMPLOYEE ADD CHECK(SALARY >0);
ALTER TABLE EMPLOYEE ADD UNIQUE(EMP_NO);

-- 레퍼런스 뒤에 테이블만 쓰면 그 테이블의 PK랑 연결됨.(실제로는 어느정도 비슷한 애들끼리 자동으로 잡히는듯?)
ALTER TABLE DEPARTMENT ADD FOREIGN KEY(LOCATION_ID) REFERENCES LOCATION;
ALTER TABLE LOCATION ADD FOREIGN KEY(NATIONAL_CODE) REFERENCES NATIONAL;

SELECT C1.TABLE_NAME, C1.CONSTRAINT_NAME, CONSTRAINT_TYPE, COLUMN_NAME, SEARCH_CONDITION
FROM USER_CONSTRAINTS C1
JOIN USER_CONS_COLUMNS C2 ON(C1.TABLE_NAME = C2.TABLE_NAME
																AND C1.CONSTRAINT_NAME = C2. CONSTRAINT_NAME)
WHERE C1.TABLE_NAME IN ('EMPLOYEE','DEPARTMENT', 'LOCATION');
						
-- DML(데이터 조작 언어)
-- INSERT, UPDATE, DELETE, SELECT(DQL)
-- [CRUD]
-- C(CREATE)			: INSERT
-- R(READ)				: SELECT
-- U(UPDATE)			: UPDATE
-- D(DELETE)			: DELETE

-- INSERT : 새로운 행을 특정 테이블에 추가하는 명령어
--				실행후에는 테이블의 행의 갯수가 증가

-- [사용형식]
-- 1. 특정 컬럼에 값을 추가하는 방법
-- INSERT INTO 테이블명(컬럼명, . . . .) VALUES(값1, . . . .);
-- 2. 모든 컬럼에 값을 추가하는 방법
-- INSERT INTO 테이블명 VALUES(값, 값, 값, ...);

SELECT * FROM EMPLOYEE WHERE 1= 2;
-- 컬럼명을 명시하여 데이터 추가
INSERT INTO EMPLOYEE(EMP_ID, EMP_NAME, EMP_NO, EMAIL, PHONE, DEPT_CODE, JOB_CODE, 
 				SAL_LEVEL, SALARY, BONUS, MANAGER_ID, HIRE_DATE, ENT_DATE, ENT_YN)
 VALUES(500, '추민석','700101-1234556','choo@kh.or.kr','01011112222', 'D1','J7',
					'S4',3100000, 0.1 ,'200',SYSDATE,NULL,DEFAULT);

SELECT * FROM EMPLOYEE WHERE EMP_NAME = '추민석';

-- 컬럼을 생략하고 사용하기(모든 컬럼에 값 추가)
INSERT INTO EMPLOYEE 
VALUES(900, '박응서', '510101-1234567','park@kh.or.kr','01022334444','D1','J7','S3',43000000,
				0.2, '200', SYSDATE, NULL, DEFAULT);

SELECT * FROM EMPLOYEE;

--지금까지 변경된 내용을 실제 DB에 반영하겠다.
COMMIT;

-- INSERT + SUBQUERY
-- VALUES 대신 값을 지정하여 추가 가능
CREATE TABLE EMP_01(
				EMP_ID NUMBER,
				EMP_NAME VARCHAR2(20),
				DEPT_TITLE VARCHAR2(40)
);
INSERT INTO EMP_01(
					SELECT EMP_ID, EMP_NAME, DEPT_TITLE
					FROM EMPLOYEE
					LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
);

SELECT * FROM EMP_01;

--
CREATE TABLE EMP_DEPT_D1
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE
		FROM EMPLOYEE 
		WHERE 1=2;

-- EMPLOYEE 테이블에서 D1부서에 근무하는 직원들의
-- 사번, 이름, 부서코드, 입사일을 조회하여 
-- EMP_DEPT_D1 테이블에 추가

SELECT * FROM EMP_DEPT_D1;	
	
INSERT INTO EMP_DEPT_D1(
					SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE
					FROM EMPLOYEE
					WHERE DEPT_CODE = 'D1'
);

COMMIT;

CREATE TABLE EMP_OLD
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
	FROM EMPLOYEE 
	WHERE 1=2;
CREATE TABLE EMP_NEW
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
	FROM EMPLOYEE 
	WHERE 1=2;

-- EMPLOYEE 테이블에서
-- 입사일 기준 2000년 1월 1일 이전 입사자의 사번, 이름, 입사일 급여를 EMP_OLD에 추가
-- 기준일 이후 입사자들의 사번, 이름, 입사일 급여를 EMP_NEW에 추가하여 처리

INSERT ALL 
			WHEN HIRE_DATE <'2000/01/01'
			THEN INTO EMP_OLD VALUES(EMP_ID,EMP_NAME,HIRE_DATE,SALARY)
			WHEN HIRE_DATE >= '2000/01/01'
			THEN INTO EMP_NEW VALUES(EMP_ID,EMP_NAME,HIRE_DATE,SALARY)
SELECT * FROM EMPLOYEE;


SELECT * FROM EMP_OLD;
SELECT * FROM EMP_NEW;

COMMIT;

-- UPDATE : 해당 테이블의 데이터를 수정하는 명령어
-- [사용형식]
-- UPDATE 테이블명 SET 컬럼명 = 변경할 값
-- [WHERE 컬럼명 비교연산자 비교값]

CREATE TABLE DEPT_COPY
AS SELECT * FROM DEPARTMENT;

SELECT * FROM DEPT_COPY;

-- D9부서를 총무부 -> 전략기획부

COMMIT;

--테이블에서 해당컬럼의 값을 다 바꿈
UPDATE DEPT_COPY 
SET DEPT_TITLE = '전략기획부';

ROLLBACK;

UPDATE DEPT_COPY 
SET DEPT_TITLE = '전략기획부'
WHERE DEPT_ID = 'D9';

SELECT * FROM DEPT_COPY;
COMMIT;

-- EMPLOYEE 테이블에서 사번이 200, 201, 214인 사원의 주민등록번호 앞자리를
-- 621130, 630126, 850507로 수정
-- UPDATE문 3개 작성

UPDATE EMPLOYEE
SET EMP_NO = REPLACE(EMP_NO,SUBSTR(EMP_NO,1,6),621130)
WHERE EMP_ID = '200';

UPDATE EMPLOYEE
SET EMP_NO = REPLACE(EMP_NO,SUBSTR(EMP_NO,1,6),630126)
WHERE EMP_ID = '201';

UPDATE EMPLOYEE
SET EMP_NO = REPLACE(EMP_NO,SUBSTR(EMP_NO,1,6),850507)
WHERE EMP_ID = '214';

SELECT * FROM EMPLOYEE;

--강사님 버전
UPDATE EMPLOYEE SET EMP_NO = '621130' || SUBSTR(EMP_NO,7)
WHERE EMP_ID = 200;

-- UPDATE + SUBQUERY
-- 여러 행을 변경하거나, 여러 컬럼의 값을 변경하고자 할 때 서브쿼리를 사용하여 UPDATE를 작성할 수 있다.
-- UPDATE 테이블 SET 컬럼명 = ( 서브쿼리 );
CREATE TABLE EMP_SALARY
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY, BONUS
		FROM EMPLOYEE;
	
SELECT * FROM EMP_SALARY
WHERE EMP_NAME IN('유재식','방명수');

-- 유재식 사원과 같은 급여와 보너스를 받고 싶어하는 방명수 사원의 
-- 급여와 보너스를 유재식 사원과 같은 값으로 변경하는 쿼리 작성
UPDATE EMP_SALARY
SET SALARY  = (SELECT SALARY FROM EMP_SALARY WHERE EMP_NAME = '유재식'),
		BONUS = (SELECT BONUS FROM EMP_SALARY WHERE EMP_NAME = '유재식')
WHERE EMP_NAME = '방명수';

SELECT * FROM EMP_SALARY
WHERE EMP_NAME IN('유재식','방명수');


-- '노옹철','전형돈','정중하','하동운'의 급여와 보너스를 유재식 사원과 같게 수정
-- 단, 다중열 서브쿼리로 구현

UPDATE EMP_SALARY 
SET (SALARY,BONUS) = (SELECT SALARY,BONUS
											FROM EMP_SALARY
											WHERE EMP_NAME = '유재식'
											)
WHERE EMP_NAME IN('노옹철','전형돈','정중하','하동운');

SELECT * FROM EMP_SALARY
WHERE EMP_NAME IN('유재식','방명수','노옹철','전형돈','정중하','하동운');

-- UPDATE시 변경할 값이 제약조건에 위배되지 않아야 한다.
-- integrity constraint (TEST.SYS_C007132) violated - parent key not found
UPDATE EMPLOYEE
SET DEPT_CODE = 'D0'
WHERE DEPT_CODE = 'D6';

--cannot update ("TEST"."EMPLOYEE"."EMP_ID") to NULL
-- EMP_ID에 NOT NULL 제약조건 위배가 됨.
UPDATE EMPLOYEE
SET EMP_ID = NULL
WHERE EMP_ID = 200;

SELECT * FROM EMPLOYEE;

--unique constraint (TEST.SYS_C007137) violated
UPDATE EMPLOYEE
SET EMP_NO = '630126-1548654'
WHERE EMP_NAME ='선동일';

SELECT * FROM EMPLOYEE WHERE EMP_ID =222;
-- UPDATE 시 DEFAULT 활용 --
UPDATE EMPLOYEE 
SET ENT_YN = DEFAULT
WHERE EMP_ID = 222;


