-- GROUP BY : 주어진 결과를 특정 소그룹으로 편성할 때 사용하는 문법
-- HAVING : 그룹 내의 조건을 설정할 때 사용한다.

/*
 * 	- 쿼리 실행 순서
 *		5 : SELECT 컬럼명
 *		1 : FROM 테이블명
 *		2: WHERE 조건식
 *		3 : GROUP BY 컬럼명
 *		4 : HAVING 그룹내의 조건식
 *		6 : ORDER BY 표현식
 */

-- 실습1.
-- EMPLOYEE 테이블에서 직급별 그룹을 편성하여 직급코드, 급여합계, 급여평균, 인원 수를 조회
-- 단, 인원수는 3명을 초과하는 직급만을 조회
SELECT JOB_CODE "직급코드",
				SUM(SALARY) "급여합계",
				AVG(SALARY) "급여평균",
				COUNT(*) "인원 수"
FROM EMPLOYEE
GROUP BY JOB_CODE
HAVING COUNT(*) >3
ORDER BY 4 DESC;

--DECODE()
--DECODE(컬럼명, 결과1, 값1 [, 결과값2, 값2 ......], 기본값) 
SELECT EMP_NAME,
				DECODE(SUBSTR(EMP_NO,8,1),1,'남성',2,'여성')
FROM EMPLOYEE;


-- SET OPERATOR --     (위 아래로 붙인다고 생각하면 됨. 즉, 컬럼의 구성이 같아야 빼거나, 더하거나, 교집합을 구할 수 있음)
-- 두개 이상의 SELECT 한 결과를 합치거나, 
-- 중복을 별도로 제거하거나 하는 집합 형태의 결과로 조회하는 명령어

-- 합집합 -- 
-- UNION : 두 개 이상의 SELECT한 결과를 구하는 명령어
-- 중복이 있을 경우 중복되는 결과는 1번만 보여준다.
-- UNION ALL : 두 개 이상의 SELECT한 결과를 보여 주되, 중복이 있을 경우에 그대로 조회하여 보여준다.  (마치 SET이냐 LIST이냐 인듯)

-- 교집합 --
-- INTERSECT : 두 개 이상의 결과 중 중복되는 결과만 보여준다.

-- 차집합 --
-- MINUS : 두 개 이상의 결과 중 첫번째 결과만이 가진 내용을 보여주는 명령어

-- SELECT 결과인 A와 B를 하나로 합치는 경우
-- A와 B의 컬럼 개수와 자료형은 반드시 같아야 한다!!

-- UNION
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION 
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > 3000000;

-- UNION ALL
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION ALL
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > 3000000;

-- INTERSECT
SELECT EMP_ID,EMP_NAME,DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
INTERSECT
SELECT EMP_ID,EMP_NAME,DEPT_CODE,SALARY
FROM EMPLOYEE
WHERE SALARY  > 3000000;

-- MINUS
SELECT EMP_ID,EMP_NAME,DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
MINUS
SELECT EMP_ID,EMP_NAME,DEPT_CODE,SALARY
FROM EMPLOYEE
WHERE SALARY  > 3000000;

-- JOIN --
-- 두 개 이상의 테이블을 하나로 합쳐서 사용하는 명령어

-- 만약에 'J6'라는 직급을 가진 사원들의 근무 부서명이 궁금하다면 ???
SELECT EMP_NAME, JOB_CODE, DEPT_CODE
FROM EMPLOYEE
WHERE JOB_CODE = 'J6'; -- D8, D1

SELECT * FROM DEPARTMENT;

SELECT DEPT_ID, DEPT_TITLE
FROM DEPARTMENT
WHERE DEPT_ID  IN('D1','D8');

-- 오라클 전용 문법 / ANSI 표준 문법

-- 오라클 전용 문법
-- FROM 절에 ','기호를 붙여 합치게 될 테이블들을 나열
-- WHERE 조건을 통해서 합칠 테이블들의 공통 사항을 작성
SELECT EMP_ID, EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE = DEPT_ID;

SELECT * FROM EMPLOYEE;
SELECT * FROM JOB;

SELECT EMP_ID, EMP_NAME, E.JOB_CODE, JOB_NAME
FROM EMPLOYEE E, JOB J
WHERE E.JOB_CODE = J.JOB_CODE;

SELECT*
FROM EMPLOYEE E, JOB J
WHERE E.JOB_CODE = J.JOB_CODE;

SELECT *
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE = DEPT_ID;    --JOIN 되지 않은 ROW는 다 버려짐

----------------------------------------------
-- ANSI 표준 문법
-- 조인하고자 하는 테이블을 FROM 구문 다음에
-- JOIN 테이블명 ON() | USING() 구문을 사용하여
-- 두 개 이상의 테이블을 하나로 합치는 방법

-- 두 개의 테이블에서 공통 컬럼의 이름이 다를 경우
SELECT EMP_ID, EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON(EMPLOYEE.DEPT_CODE = DEPARTMENT.DEPT_ID);  --EMPLOYEE나 DEPARTMENT 생략 가능

-- 두 개의 테이블에서 공통 컬럼의 이름이 같은 경우
SELECT EMP_ID, EMP_NAME, EMPLOYEE.JOB_CODE, JOB_NAME
FROM EMPLOYEE
JOIN JOB ON(JOB.JOB_CODE = EMPLOYEE.JOB_CODE);
-- 위에처럼도 쓸 수 있지만 비효율적
SELECT EMP_ID, EMP_NAME, JOB_CODE, JOB_NAME
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE);   -- 위에꺼와 비교하면 확실히 간결해짐

-- 실습 2.
-- EMPLOYEE 테이블의 직원 급여 정보와 SAL_GRADE의 급여 등급을 합쳐서
-- 사번, 사원명, 급여등급, 등급 기준 최소급여, 최대급여를 조회

-- 연결하고자 하는 테이블 정보 조회
SELECT * FROM SAL_GRADE;
SELECT * FROM EMPLOYEE;

-- 오라클 버전 --
SELECT EMP_ID, EMP_NAME, EMPLOYEE.SAL_LEVEL,MIN_SAL, MAX_SAL
FROM EMPLOYEE, SAL_GRADE
WHERE EMPLOYEE.SAL_LEVEL  = SAL_GRADE.SAL_LEVEL;

-- ANSI 버전 --
SELECT EMP_ID, EMP_NAME, SAL_LEVEL,MIN_SAL, MAX_SAL
FROM EMPLOYEE
JOIN SAL_GRADE USING(SAL_LEVEL);   -- ANSI 동일 컬럼

SELECT EMP_ID, EMP_NAME,EMPLOYEE.SAL_LEVEL,MIN_SAL, MAX_SAL
FROM EMPLOYEE
JOIN SAL_GRADE ON(SAL_GRADE.SAL_LEVEL  = EMPLOYEE.SAL_LEVEL);  -- ANSI 다른 컬럼

-- 실습 3.
-- DEPARTMENT 테이블의 위치 정보
-- LOCATION 테이블을 조인하여 각 부서별 근무지 위치를 조회
-- 부서코드, 부서명, 근무지 코드, 근무지 위치
SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;

-- 오라클 --
SELECT DEPT_ID, DEPT_TITLE, LOCATION.LOCAL_CODE , LOCAL_NAME
FROM DEPARTMENT, LOCATION
WHERE DEPARTMENT.LOCATION_ID  = LOCATION.LOCAL_CODE;

-- ANSI --
SELECT DEPT_ID, DEPT_TITLE, LOCATION.LOCAL_CODE , LOCAL_NAME
FROM DEPARTMENT
JOIN LOCATION ON(LOCATION.LOCAL_CODE  = DEPARTMENT.LOCATION_ID );

-- INNER JOIN / OUTER JOIN --
-- 두 개 이상의 테이블을 합칠 때
-- INNER JOIN은 둘 모두 일치하는 데이터만 합치고,
-- OUTER JOIN은 둘 중 하나, 혹은 둘 모두가 가진 모든 값을 합칠 때 사용

-- INNER JOIN
SELECT DISTINCT DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID )
ORDER BY 1;

-- OUTER JOIN --
-- LEFT [OUTER] JOIN : 두 테이블 중 원본(좌측) 테이블의 정보를 모두 포함하여 조회
-- RIGHT [OUTER] JOIN : 두 테이블 중 JOIN에 명시한 테이블의 정보를 모두 포함하여 조회
-- FULL [OUTER] JOIN : 두 테이블이 가진 데이터 중 서로가 가지지 않은 값이라도 모두 포함하여 조회

-- LEFT JOIN -- 
-- ANSI 표준
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID );
-- ORACLE 구문
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE  = DEPT_ID(+);   
-- +를 안쓰면 그냥 INNER JOIN이지만 DEPT_ID에 +쓰면 LEFT JOIN이 됨.
-- +위치가 DEPT_CODE에 있으면 RIGHT JOIN이 됨.
-- DEPT_ID가 없어도 추가 해라 하는식으로 이해하면 될 듯.(DEPT_CODE를 기준으로 생각하는 것)


-- RIGHT JOIN --
--ANSI 표준
SELECT DEPT_CODE, DEPT_ID, EMP_NAME
FROM EMPLOYEE
RIGHT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID);
-- ORACLE 구문
SELECT DEPT_CODE, DEPT_ID, EMP_NAME
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE(+) = DEPT_ID;

-- FULL JOIN --
--ANSI 표준--
SELECT DEPT_CODE, DEPT_ID, EMP_NAME
FROM EMPLOYEE
FULL JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID);
-- ORACLE
-- ORACLE 구문에서는 FULL JOIN을 지원하지 않는다.
-- 밑에 써 있는걸로 백날 해봤자 안됨
SELECT DEPT_CODE, DEPT_ID, EMP_NAME
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE(+) = DEPT_ID(+);


-- CROSS JOIN   (CARTESIAN PRODUCT)  -- 웬만하면 사용 안하는게 ....
SELECT EMP_NAME, NATIONAL_CODE
FROM EMPLOYEE
CROSS JOIN NATIONAL;

SELECT NATIONAL_CODE
FROM NATIONAL;

-- SELF JOIN --
-- 자기 자신을 조인하는 방법
-- 한 테이블의 정보 중 값 비교가 필요한 정보들을 계산하여 조회하는 방식

-- 직원의 정보와 직원을 관리하는 매니저의 정보를 조회
SELECT * FROM EMPLOYEE;

-- ANSI --
SELECT * 
FROM EMPLOYEE E
JOIN EMPLOYEE M ON(E.MANAGER_ID  = M.EMP_ID );
-- ORACLE --
SELECT E.EMP_ID 사번,
				E.EMP_NAME 사원명,
				E.MANAGER_ID "관리자 사번",
				M.EMP_NAME 관리자명
FROM EMPLOYEE E, EMPLOYEE M
WHERE E.MANAGER_ID = M.EMP_ID;

-- 다중 JOIN --
-- 여러 개의 테이블을 JOIN하는 것
-- 일반 조인과 선언방식은 같으나, 앞서 조인한 결과를 기준으로 이후에 조인할 테이블을 연결 짓는다.
-- 따라서 조인 순서에 반드시 주의 해야한다.

SELECT * FROM LOCATION ; -- LOCAL_CODE
SELECT * FROM DEPARTMENT; -- DEPT_ID, LOCATION_ID
SELECT * FROM EMPLOYEE;  -- DEPT_CODE
--ANSI 표준 --
--공통부분이 없으면 합칠 수 없으니 순서를 잘 해서 JOIN해야됨
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID )
JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE );

-- ORACLE --
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE, DEPARTMENT, LOCATION
WHERE (DEPT_CODE = DEPT_ID) AND (LOCATION_ID = LOCAL_CODE);

-- 실습 4.
-- 직급이 대리이면서, 아시아 지역에서 근무하는 사원 조회
-- 사번, 사원명, 직급명, 부서명, 근무지역명, 급여
SELECT * FROM EMPLOYEE;
SELECT * FROM LOCATION;
SELECT * FROM DEPARTMENT;
SELECT * FROM JOB;  -- JOBCODE J6

SELECT EMP_ID, EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME, SALARY
FROM EMPLOYEE, JOB,DEPARTMENT, LOCATION
WHERE (JOB.JOB_CODE =  EMPLOYEE.JOB_CODE AND EMPLOYEE.JOB_CODE = 'J6') 
				AND DEPARTMENT.LOCATION_ID  = LOCATION.LOCAL_CODE 
				AND (EMPLOYEE.DEPT_CODE  = DEPARTMENT.DEPT_ID AND  LOCAL_NAME LIKE 'ASIA%');

			
			
			-- 강사님 버전 --
-- ANSI --
SELECT EMP_ID, EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME, SALARY
FROM EMPLOYEE E
JOIN JOB J ON(E.JOB_CODE  = J.JOB_CODE AND JOB_NAME = '대리')
JOIN DEPARTMENT ON(DEPT_ID  = DEPT_CODE)
JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE AND LOCAL_NAME LIKE 'ASIA%');
--ORACLE--
SELECT EMP_ID, EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME, SALARY
FROM EMPLOYEE E, JOB J, DEPARTMENT D , LOCATION L
WHERE E.JOB_CODE = J.JOB_CODE 
			AND DEPT_CODE = DEPT_ID 
			AND LOCAL_CODE  = LOCATION_ID
			AND JOB_NAME = '대리'
			AND LOCAL_NAME LIKE 'ASIA%';


-- 실습 5
-- 한국(KO)과 일본(JP)에 근무하는 근무 직원들의 정보를 조회하시오
-- 사원명, 부서명, 지역명, 국가명
SELECT * FROM EMPLOYEE;
SELECT * FROM LOCATION;
SELECT * FROM DEPARTMENT;

--ANSI 표준 --
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME, NATIONAL_CODE
FROM EMPLOYEE E
JOIN DEPARTMENT D ON(D.DEPT_ID = E.DEPT_CODE )
JOIN LOCATION L ON(L.LOCAL_CODE  = D.LOCATION_ID AND NATIONAL_CODE IN('KO','JP'));
--강사님 버전 ANSI 표준 --
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME, NATIONAL_NAME
FROM EMPLOYEE E
JOIN DEPARTMENT D ON(D.DEPT_ID = E.DEPT_CODE )
JOIN LOCATION L ON(L.LOCAL_CODE  = D.LOCATION_ID)
JOIN NATIONAL N ON 	(L.NATIONAL_CODE  = N.NATIONAL_CODE )
WHERE NATIONAL_NAME  IN('한국','일본');


-- ORACLE -- 
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME, NATIONAL_CODE
FROM EMPLOYEE E, DEPARTMENT D , LOCATION L 
WHERE D.DEPT_ID = E.DEPT_CODE 
		AND L.LOCAL_CODE  = D.LOCATION_ID 
			AND L.NATIONAL_CODE IN('KO','JP');
-- 강사님 버전 ORACLE -- 
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME, NATIONAL_NAME
FROM EMPLOYEE E, DEPARTMENT D , LOCATION L , NATIONAL N
WHERE D.DEPT_ID = E.DEPT_CODE 
		AND L.LOCAL_CODE  = D.LOCATION_ID 
		AND L.NATIONAL_CODE  = N.NATIONAL_CODE 
			AND NATIONAL_NAME IN('한국','일본');


-----------------------------
-- Sub Query --
-- 주가 되는 메인 쿼리 안에서 조건이나 하나의 검색을 위한
-- 다른 쿼리를 추가하는 기법

-- 단일 행 서브쿼리
-- 결과값이 1개 나오는 서브쿼리
		
-- EX) 최소 급여를 받는 사원의 정보 조회
SELECT MIN(SALARY)
FROM EMPLOYEE; -- 1380000
SELECT * FROM EMPLOYEE
WHERE SALARY = 1380000;

SELECT *
FROM EMPLOYEE
WHERE SALARY = (SELECT MIN(SALARY) 
										FROM EMPLOYEE);

-- 다중 행 서브쿼리
-- 결과 값이 여러 줄 나오는 서브쿼리

-- 각 직급별 최소 급여
SELECT JOB_CODE, MIN(SALARY)
FROM EMPLOYEE
GROUP BY JOB_CODE;

SELECT * 
FROM EMPLOYEE
WHERE SALARY IN (SELECT MIN(SALARY) 
										FROM EMPLOYEE
											GROUP BY JOB_CODE);


-- 다중 열 다중 행 서브쿼리
-- 여러 컬럼과 여러 줄을 가진 서브쿼리를 사용하여 결과를 조회
SELECT *
FROM EMPLOYEE
WHERE (JOB_CODE, SALARY) IN (SELECT JOB_CODE, MIN(SALARY) 
																	FROM EMPLOYEE
																	GROUP BY JOB_CODE);
										
-- 다중 행 다중 열 서브쿼리와 일반 단일 행 서브쿼리 차이
-- EX) 퇴사한 여직원과 같은 직급, 같은 부서에 근무하는 직원들의 정보를 조회
SELECT *
FROM EMPLOYEE
WHERE ENT_YN  = 'Y';

SELECT *
FROM EMPLOYEE
WHERE (JOB_CODE, DEPT_CODE ) IN ( SELECT JOB_CODE, DEPT_CODE 
																			FROM EMPLOYEE 
																			WHERE ENT_YN  = 'Y');
										
SELECT *
FROM EMPLOYEE
WHERE DEPT_CODE  = (SELECT DEPT_CODE 
											FROM EMPLOYEE
											WHERE ENT_YN = 'Y')
				AND JOB_CODE = (SELECT JOB_CODE 
											FROM EMPLOYEE
											WHERE ENT_YN  = 'Y')
				AND EMP_NAME  <> (SELECT EMP_NAME 
													FROM EMPLOYEE
													WHERE ENT_YN = 'Y');
				
-- 다중 열 다중 행 서브쿼리로 변경
SELECT *
FROM EMPLOYEE
WHERE (DEPT_CODE, JOB_CODE) = (SELECT DEPT_CODE ,JOB_CODE
																						FROM EMPLOYEE
																					WHERE ENT_YN = 'Y')
				AND EMP_NAME  <> (SELECT EMP_NAME
														FROM EMPLOYEE
														WHERE ENT_YN = 'Y');																	
										
-- 서브 쿼리의 사용 위치
-- SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY, JOIN
-- DML : INSERT, UPDATE, DELETE
-- DDL : CREATE TABLE, CREATE VIEW
-- 어느 위치든 사용 할 수 있다.

-- Inline View(인라인 뷰)
													
					
